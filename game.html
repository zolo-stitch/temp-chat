<!DOCTYPE html>
<html>
<head>
    <title>FPS Labyrinthe</title>
    <style>body { margin: 0; overflow: hidden; }</style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script>
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Création du pivot pour la caméra
        const cameraPivot = new THREE.Object3D();
        scene.add(cameraPivot);
        cameraPivot.add(camera);
        camera.position.set(0, 0, 0); // Caméra centrée dans le pivot

        // Textures
        const textureLoader = new THREE.TextureLoader();
        const grassTexture = textureLoader.load('https://threejs.org/examples/textures/terrain/grasslight-big.jpg');
        grassTexture.wrapS = grassTexture.wrapT = THREE.RepeatWrapping;
        grassTexture.repeat.set(10, 10);

        const brickTexture = textureLoader.load('https://threejs.org/examples/textures/brick_diffuse.jpg');
        brickTexture.wrapS = brickTexture.wrapT = THREE.RepeatWrapping;
        brickTexture.repeat.set(5, 1);

        // Ciel
        const skyGeometry = new THREE.SphereGeometry(500, 32, 32);
        const skyMaterial = new THREE.MeshBasicMaterial({ color: 0x87CEEB, side: THREE.BackSide });
        const sky = new THREE.Mesh(skyGeometry, skyMaterial);
        scene.add(sky);

        // Labyrinthe
        const mazeWidth = 21;
        const mazeHeight = 21;
        const cellSize = 2;
        const maze = [];
        const walls = [];

        function generateMaze() {
            for (let x = 0; x < mazeWidth; x++) {
                maze[x] = [];
                for (let z = 0; z < mazeHeight; z++) {
                    maze[x][z] = 1;
                }
            }

            function carve(x, z) {
                maze[x][z] = 0;
                const directions = [[0, 2], [2, 0], [0, -2], [-2, 0]];
                directions.sort(() => Math.random() - 0.5);

                for (let [dx, dz] of directions) {
                    const nx = x + dx;
                    const nz = z + dz;
                    if (nx > 0 && nx < mazeWidth - 1 && nz > 0 && nz < mazeHeight - 1 && maze[nx][nz] === 1) {
                        maze[x + dx / 2][z + dz / 2] = 0;
                        carve(nx, nz);
                    }
                }
            }

            carve(1, 1);
            maze[1][0] = 0;
            maze[mazeWidth - 2][mazeHeight - 1] = 0;
        }

        function buildMaze() {
            const floorGeometry = new THREE.PlaneGeometry(mazeWidth * cellSize, mazeHeight * cellSize);
            const floorMaterial = new THREE.MeshBasicMaterial({ map: grassTexture });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            scene.add(floor);

            const wallGeometry = new THREE.BoxGeometry(cellSize, 5, cellSize);
            const wallMaterial = new THREE.MeshBasicMaterial({ map: brickTexture });

            for (let x = 0; x < mazeWidth; x++) {
                for (let z = 0; z < mazeHeight; z++) {
                    if (maze[x][z] === 1) {
                        const wall = new THREE.Mesh(wallGeometry, wallMaterial);
                        wall.position.set(
                            (x - mazeWidth / 2) * cellSize,
                            2.5,
                            (z - mazeHeight / 2) * cellSize
                        );
                        scene.add(wall);
                        walls.push(wall);
                    }
                }
            }
        }

        generateMaze();
        buildMaze();

        // Position initiale du pivot
        cameraPivot.position.set(-mazeWidth * cellSize / 2 + cellSize, 2, -mazeHeight * cellSize / 2 + cellSize);

        // Arme
        const gunGeometry = new THREE.BoxGeometry(0.2, 0.1, 0.5);
        const gunMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
        const gun = new THREE.Mesh(gunGeometry, gunMaterial);
        gun.position.set(0.3, -0.3, -0.5);
        camera.add(gun);

        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let velocity = new THREE.Vector3();
        const speed = 0.1;
        const playerBullets = [];
        const enemies = [];

        function createEnemy(x, z) {
            const enemyGeometry = new THREE.BoxGeometry(1, 2, 1);
            const enemyMaterial = new THREE.MeshBasicMaterial({ color: 0x0000ff });
            const enemy = new THREE.Mesh(enemyGeometry, enemyMaterial);
            enemy.position.set(x, 1, z);
            enemy.visible = true;
            enemy.alive = true;
            scene.add(enemy);
            enemies.push(enemy);
            return enemy;
        }

        createEnemy(0, 0);
        createEnemy(mazeWidth * cellSize / 4, mazeHeight * cellSize / 4);

        // Contrôles
        document.addEventListener('keydown', (event) => {
            switch (event.code) {
                case 'KeyW': moveForward = true; break;
                case 'KeyS': moveBackward = true; break;
                case 'KeyA': moveLeft = true; break;
                case 'KeyD': moveRight = true; break;
                case 'Space': if (cameraPivot.position.y <= 2) velocity.y = 0.2; break;
            }
        });

        document.addEventListener('keyup', (event) => {
            switch (event.code) {
                case 'KeyW': moveForward = false; break;
                case 'KeyS': moveBackward = false; break;
                case 'KeyA': moveLeft = false; break;
                case 'KeyD': moveRight = false; break;
            }
        });

        document.body.requestPointerLock = document.body.requestPointerLock || document.body.mozRequestPointerLock;
        document.addEventListener('click', () => {
            document.body.requestPointerLock();
            shoot();
        });

        document.addEventListener('mousemove', (event) => {
            if (document.pointerLockElement === document.body || document.mozPointerLockElement === document.body) {
                const movementX = event.movementX || 0;
                const movementY = event.movementY || 0;

                // Rotation horizontale sur le pivot
                cameraPivot.rotation.y -= movementX * 0.002;

                // Rotation verticale sur la caméra
                camera.rotation.x -= movementY * 0.002;
                camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x)); // Limite ±90°
            }
        });

        function shoot() {
            const bulletGeometry = new THREE.SphereGeometry(0.1, 8, 8);
            const bulletMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);
            bullet.position.copy(cameraPivot.position); // Position initiale au pivot
            bullet.position.add(camera.getWorldDirection(new THREE.Vector3()).multiplyScalar(1));
            bullet.velocity = camera.getWorldDirection(new THREE.Vector3()).multiplyScalar(0.5);
            scene.add(bullet);
            playerBullets.push(bullet);
        }

        function animate() {
            requestAnimationFrame(animate);

            velocity.y -= 0.01;
            const direction = new THREE.Vector3();
            if (moveForward) direction.add(camera.getWorldDirection(new THREE.Vector3()));
            if (moveBackward) direction.sub(camera.getWorldDirection(new THREE.Vector3()));
            if (moveLeft) direction.sub(camera.getWorldDirection(new THREE.Vector3()).cross(new THREE.Vector3(0, 1, 0)));
            if (moveRight) direction.add(camera.getWorldDirection(new THREE.Vector3()).cross(new THREE.Vector3(0, 1, 0)));
            direction.normalize().multiplyScalar(speed);
            cameraPivot.position.add(direction); // Déplace le pivot
            cameraPivot.position.y += velocity.y;
            if (cameraPivot.position.y < 2) {
                cameraPivot.position.y = 2;
                velocity.y = 0;
            }

            walls.forEach(wall => {
                const playerBox = new THREE.Box3().setFromCenterAndSize(
                    cameraPivot.position, // Utilise la position du pivot
                    new THREE.Vector3(1, 2, 1)
                );
                const wallBox = new THREE.Box3().setFromObject(wall);
                if (playerBox.intersectsBox(wallBox)) {
                    cameraPivot.position.sub(direction); // Annule le déplacement du pivot
                }
            });

            playerBullets.forEach((bullet, index) => {
                bullet.position.add(bullet.velocity);
                if (bullet.position.length() > 100) {
                    scene.remove(bullet);
                    playerBullets.splice(index, 1);
                }
            });

            renderer.render(scene, camera);
        }

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>